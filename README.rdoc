= Technical Analysis Indicator Library

== Overview

Provides a wrapper around the talib-ruby[https://github.com/rivella50/talib-ruby] library which is a ruby wrapper for the ta-lib[http://ta-lib.org/] library.

This library has been designed to make interfacing with the ta-lib functions easy by wrapping each function in a ruby class. 

The wrappers are autogenerated from the xml function description provided with the ta-lib project.

== Usage

  require 'ta_indicator'

=== Class Construction

All ta-lib functions are wrapped in a class named using the camel class name of the function: SMA is Sma, AVGPRICE is AvgPrice, etc. The constructor takes the optional arguments either as a hash or argument list. For example the Macd class takes three arguments, fast_period, slow_period and signal_period. They can be initialised in any of the following ways:
  
  sma = Sma.new 5
  macd = Macd.new 12,26,9
or
  sma = Sma.new :time_period => 5
  macd = Macd.new :fast_period => 12, :slow_period => 26, :signal_period => 9

If a parameter is not passed in then it will be initialised to the default value as specified by the ta-lib interface. 

=== Argument attributes

All arguments can be updated through attributes:
  macd.fast_period
  => 12
  macd.slow_period = 30
  => 30

A list of all the arguments that a particular class takes can be be retrieved using the class method 'arguments'.
  Macd.arguments
  => [:fast_period, :slow_period, :signal_period]
  Sma.arguments
  => [:time_period] 

=== Running The Indicators
Each indicator defines a run method that takes in each input array to be processed as a List. An example of an indicator that takes one input:
  sma = Sma.new(5)
  sma.run [1,2,3,4,3,2,3,2,3,2,3,2]
  => [nil, nil, nil, nil, 2.6, 2.8, 3.0, 2.8, 2.6, 2.4, 2.6, 2.4]

An example of an indicator that takes two inputs:
  add = Add.new
  add.run [1,2,3,4,5], [5,4,3,2,1]
  => [6.0, 6.0, 6.0, 6.0, 6.0]

Some indicators require OHLC (and optionally V) price inputs. An example of an indicator that takes price inputs:
  avg = AvgPrice.new
  # AvgPrice run function takes open, high, low, close
  avg.run [1,2,1,2], [2,1,2,1], [3,1,3,1], [1,3,1,3]
  => [1.75, 1.75, 1.75, 1.75] 

A list of inputs that a indicator run function requires can be retrieved using the class method 'inputs'.
  Sma.inputs
  => [:in_real]
  Add.inputs
  => [:in_real0, in_real1] 
  AvgPrice.inputs
  => [:open, :high, :low, :close]
  AdOsc.inputs
  => [:open, :high, :low, :close, :volume]
   
=== Outputs
The run function returns an array containing the results if there is only one List to return otherwise it returns a hash that maps each output List to it's name. For eample:
  sma = Sma.new(5)
  sma.run [1,2,3,4,3,2,3,2,3,2,3,2]
  => [nil, nil, nil, nil, 2.6, 2.8, 3.0, 2.8, 2.6, 2.4, 2.6, 2.4]
  macd = Macd.new 3,4,1
  result = macd.run [1,2,3,4,4,3]
  puts results[:out_macd]
  => [nil, nil, -3.785768566076978e-270, 0.5, nil, nil]
  puts result[:out_macd_signal]
  => [nil, nil, 0.399999999999999, 0.189999999999999, nil, nil], 
  puts result[:out_macd_hist]
  => [nil, nil, -0.3999999999999999, 0.31000000000000005, nil, nil]
  
A list of outputs that an indicator run function returns can be retrieved using the class method 'outputs'.
  Sma.outputs
  => [:out_real]
  Macd.outputs
  => [:out_macd, :out_macd_signal, :out_macd_hist]

=== Data Mapping
The run function also accepts a DataMapping::Map structure which can be used to extract data from an enumerable collection.

  # Assume historical_data is a list of hashes with the following keys
  # :open, :high, :low, :close, :volume
  sma = Sma.new 5
  sma_results = sma.run(DataMapper::Map.new(historical_data, :open))

When the above example is run the DataMapper will attempt to extract data from the historical_data collection by either calling a function called open or retrieving a hash value using the key :open. You can also directly pass in a lambda function if a more complex mapping function is required.
To reduce the amount of code required a helper function called new_map is available:

  sma = Sma.new 5
  sma_results = sma.run new_map(historical_data, :open)
  sma_results = sma.run new_map(historical_data, lambda => |b| { b[:open] / 2 })

By default the run function will attempt to use a default getter of :open, so the following is also valid:
  
  sma = Sma.new 5
  sma_results = sma.run historical_data 
  # Calculates the sma by accessing [:open] on each element of historical_data

The default getter can be changed:
  sma = Sma.new 5
  sma.default_getter :high
  sma_results = sma.run historical_data 
  # Calculates the sma by accessing [:high] on each element of historical_data

The same mapping system works for functions requiring price data as an input. The AvgPrice function can be called using either of the following syntax:
  
  ap = AvgPrice.new
  ap.run(
    new_map(historical_data, :open), 
    new_map(historical_data, :high), 
    new_map(historical_data, :low), 
    new_map(historical_data, :close))

or

  ap = AvgPrice.new
  ap.run historical_data

The run function will again attempt to use sensible default mappings of :open, :high, :low, :close and :volume (if required).

== Copyright

Copyright (c) 2011 Michael Lamb. See LICENSE for details.
